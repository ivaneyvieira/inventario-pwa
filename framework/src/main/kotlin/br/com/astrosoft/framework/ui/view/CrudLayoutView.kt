package br.com.astrosoft.framework.ui.view

import br.com.astrosoft.framework.viewmodel.CrudViewModel
import br.com.astrosoft.framework.viewmodel.EntityVo
import br.com.astrosoft.framework.viewmodel.QueryView
import br.com.astrosoft.framework.viewmodel.Sort
import br.com.astrosoft.framework.viewmodel.ViewModel
import com.github.mvysny.karibudsl.v10.flexGrow
import com.github.mvysny.karibudsl.v10.init
import com.vaadin.flow.component.ClickEvent
import com.vaadin.flow.component.Component
import com.vaadin.flow.component.ComponentEventListener
import com.vaadin.flow.component.HasComponents
import com.vaadin.flow.component.button.Button
import com.vaadin.flow.component.grid.Grid
import com.vaadin.flow.component.grid.Grid.Column
import com.vaadin.flow.component.icon.Icon
import com.vaadin.flow.component.icon.VaadinIcon
import com.vaadin.flow.component.icon.VaadinIcon.REFRESH
import com.vaadin.flow.component.orderedlayout.VerticalLayout
import com.vaadin.flow.component.textfield.TextField
import com.vaadin.flow.data.binder.Binder
import com.vaadin.flow.data.provider.CallbackDataProvider
import com.vaadin.flow.data.provider.DataProvider
import com.vaadin.flow.data.provider.Query
import com.vaadin.flow.data.provider.SortDirection.DESCENDING
import org.vaadin.crudui.crud.CrudListener
import org.vaadin.crudui.crud.CrudOperation
import org.vaadin.crudui.crud.CrudOperationException
import org.vaadin.crudui.crud.impl.GridCrud
import org.vaadin.crudui.form.AbstractAutoGeneratedCrudFormFactory
import org.vaadin.crudui.form.CrudFormFactory
import org.vaadin.crudui.layout.CrudLayout
import org.vaadin.crudui.layout.impl.WindowBasedCrudLayout
import java.util.stream.*
import kotlin.reflect.KProperty1

abstract class CrudLayoutView<C: EntityVo<*>, V: CrudViewModel<*, *, C>>: LayoutView<V>() {
  lateinit var gridCrud: GridCrudFlex<C>
  override fun updateView(viewModel: ViewModel) {
    if(::gridCrud.isInitialized) gridCrud.refreshGrid()
  }

  override fun updateModel() {
  }

  fun HasComponents.gridCrud(domainType: Class<C>, block: GridCrudFlex<C>.() -> Unit = {}): GridCrudFlex<C> {
    setSizeFull()
    val crudLayout = WindowsCrud()
    crudLayout.defaults()
    val crudFormFactory = CustomCrudFormFactory(domainType, ::layoutForm)
    crudFormFactory.defaults()
    val crudListener = ViewModelCrudListener(viewModel)
    gridCrud = GridCrudFlex(domainType, crudLayout, crudFormFactory, crudListener)
    gridCrud.defaults()

    return init(gridCrud) {
      flexGrow = 1.0
      block()
    }
  }

  fun <T> GridCrudFlex<C>.column(property: KProperty1<C, T>, block: Column<C?>.() -> Unit = {}): Column<C?> {
    val column: Column<C?> = grid.addColumn(property)
    column.block()
    return column
  }

  abstract fun layoutForm(formLayout: VerticalLayout, operation: CrudOperation?, binder: Binder<C>, readOnly: Boolean)

  private fun WindowBasedCrudLayout.defaults() {
    setWindowCaption(CrudOperation.READ, "Consulta")
    setWindowCaption(CrudOperation.ADD, "Adiciona")
    setWindowCaption(CrudOperation.UPDATE, "Modifica")
    setWindowCaption(CrudOperation.DELETE, "Apaga")
    setFormWindowWidth("80%")
  }

  private fun <T: Any> CustomCrudFormFactory<T>.defaults() {
    setButtonCaption(CrudOperation.READ, "Consulta")
    setButtonCaption(CrudOperation.ADD, "Adiciona")
    setButtonCaption(CrudOperation.UPDATE, "Modifica")
    setButtonCaption(CrudOperation.DELETE, "Apaga")

    setCancelButtonCaption("Cancela")
  }

  private fun <T: EntityVo<*>> GridCrudFlex<T>.defaults() {
    grid.removeAllColumns()

    setRowCountCaption("%d registro(s) encontrados")
  }
}

class CustomCrudFormFactory<T>(domainType: Class<T>,
                               private val layoutForm: (VerticalLayout, CrudOperation?, Binder<T>, Boolean) -> Unit):
  AbstractAutoGeneratedCrudFormFactory<T>(domainType) {
  override fun buildCaption(operation: CrudOperation?, domainObject: T): String {
    TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
  }

  override fun buildNewForm(operation: CrudOperation?, domainObject: T, readOnly: Boolean,
                            cancelButtonClickListener: ComponentEventListener<ClickEvent<Button>>?,
                            operationButtonClickListener: ComponentEventListener<ClickEvent<Button>>?): Component {
    TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
  }
}

class ViewModelCrudListener<T: EntityVo<*>>(private val crudViewModel: CrudViewModel<*, *, T>): CrudListener<T> {
  override fun update(domainObjectToUpdate: T): T {
    crudViewModel.crudBean = domainObjectToUpdate
    crudViewModel.update()
    return crudViewModel.crudBean!!
  }

  override fun add(domainObjectToAdd: T): T {
    crudViewModel.crudBean = domainObjectToAdd
    crudViewModel.add()
    return crudViewModel.crudBean!!
  }

  override fun findAll(): List<T> {
    return emptyList()
  }

  override fun delete(domainObjectToDelete: T) {
    crudViewModel.crudBean = domainObjectToDelete
    crudViewModel.delete()
  }

  fun findQuery(query: QueryView): List<T> {
    crudViewModel.updateQueryView(query)
    return crudViewModel.findQuery()
  }

  fun countQuery(query: QueryView): Int {
    crudViewModel.updateQueryView(query)
    return crudViewModel.countQuery()
  }
}

class WindowsCrud: WindowBasedCrudLayout()

open class GridCrudFlex<T: EntityVo<*>>(domainType: Class<T>, crudLayout: CrudLayout,
                                        crudFormFactory: CrudFormFactory<T>,
                                        private val crudListener: ViewModelCrudListener<T>):
  GridCrud<T>(domainType, crudLayout, crudFormFactory, crudListener) {
  val find = CallbackDataProvider.FetchCallback<T, String> {query ->
    findQuery(query)
  }
  val count = CallbackDataProvider.CountCallback<T, String> {query ->
    countQuery(query)
  }
  private val dataProvider = DataProvider.fromFilteringCallbacks(find, count)
    .withConfigurableFilter()
  private var readButton: Button? = null
  private val filtroEdt = TextField {
    val value = if(it.value.isNullOrBlank()) null else it.value
    dataProvider.setFilter(value)
    refreshGrid()
  }

  init {
    grid.addItemClickListener {e ->
      if(e.clickCount == 2) if(!grid.asSingleSelect().isEmpty) if(updateButton.isVisible) updateButtonClicked()
      else readButtonClicked()
    }

    grid.dataProvider = dataProvider

    crudLayout.addFilterComponent(filtroEdt)
  }

  fun addCustomToolBarComponent(customToolBarComponent: Component) {
    crudLayout.addToolbarComponent(customToolBarComponent)
  }

  override fun updateButtonClicked() {
    val domainObject = grid.asSingleSelect()
      .value
    showForm(CrudOperation.UPDATE, domainObject, false, savedMessage) {
      try {
        val updatedObject = updateOperation.perform(domainObject)
        grid.asSingleSelect()
          .clear()
        refreshGrid()
        val items = findAllOperation.findAll()
        if(items.contains(updatedObject)) {
          grid.asSingleSelect()
            .value = updatedObject
          // grid.scrollTo(updatedObject);
        }
      } catch(e1: CrudOperationException) {
        refreshGrid()
      } catch(e2: Exception) {
        refreshGrid()
        throw e2
      }
    }
  }

  fun button(cmd: () -> Unit): Button {
    return Button().apply {
      addClickListener {cmd()}
    }
  }

  override fun initLayout() {
    findAllButton = button {refreshGrid()}
    findAllButton.icon = Icon(REFRESH)
    crudLayout.addToolbarComponent(findAllButton)

    addButton = button {addButtonClicked()}
    addButton.icon = Icon(VaadinIcon.PLUS)
    crudLayout.addToolbarComponent(addButton)

    updateButton = button {updateButtonClicked()}
    updateButton.icon = Icon(VaadinIcon.PENCIL)
    crudLayout.addToolbarComponent(updateButton)

    readButton = button {readButtonClicked()}
    readButton?.icon = Icon(VaadinIcon.SEARCH)
    crudLayout?.addToolbarComponent(readButton)

    deleteButton = button {deleteButtonClicked()}
    deleteButton.icon = Icon(VaadinIcon.TRASH)
    crudLayout.addToolbarComponent(deleteButton)

    grid = Grid<T>(domainType)
    grid.setSizeFull()
    grid.addSelectionListener {gridSelectionChanged()}
    crudLayout.setMainComponent(grid)

    updateButtons()
    queryOnly = false
  }

  var queryOnly: Boolean = false
    set(value) {
      field = value

      findAllButton.isVisible = true
      addButton.isVisible = !value
      updateButton.isVisible = !value
      readButton?.isVisible = value
      deleteButton.isVisible = !value
    }
  var addOnly: Boolean = false
    set(value) {
      field = value

      findAllButton.isVisible = true
      addButton.isVisible = true
      updateButton.isVisible = !value
      readButton?.isVisible = value
      deleteButton.isVisible = !value
    }
  var reloadOnly: Boolean = false
    set(value) {
      field = value

      findAllButton.isVisible = true
      addButton.isVisible = !value
      updateButton.isVisible = !value
      readButton?.isVisible = value
      deleteButton.isVisible = !value
    }

  override fun updateButtons() {
    val rowSelected = !grid.asSingleSelect().isEmpty
    updateButton.isEnabled = rowSelected
    deleteButton.isEnabled = rowSelected
    readButton?.isEnabled = rowSelected
  }

  private fun readButtonClicked() {
    val domainObject = grid.asSingleSelect()
      .value
    showForm(CrudOperation.READ, domainObject, false, savedMessage) {
      try {
        grid.asSingleSelect()
          .clear()
        refreshGrid()
        val items = findAllOperation.findAll()
        if(items.contains(domainObject)) {
          grid.asSingleSelect()
            .value = domainObject
          // grid.scrollTo(updatedObject);
        }
      } catch(e1: CrudOperationException) {
        refreshGrid()
      } catch(e2: Exception) {
        refreshGrid()
        throw e2
      }
    }
  }

  override fun gridSelectionChanged() {
    updateButtons()
  }

  override fun refreshGrid() {
    grid.dataProvider.refreshAll()
  }

  private fun findQuery(query: Query<T, String>): Stream<T> {
    return crudListener.findQuery(query.viewQuery())
      .stream()
  }

  private fun countQuery(query: Query<T, String>): Int {
    return crudListener.countQuery(query.viewQuery())
  }
}

fun <T> Query<T, String>.viewQuery(): QueryView {
  val sorts = this.sortOrders.map {
    Sort(it.sorted, it.direction == DESCENDING)
  }
  return QueryView(this.offset, this.limit, this.filter.orElse(""), sorts)
}